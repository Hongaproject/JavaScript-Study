// var, let, const
// var은 재선언과 재할당이 가능해지며 호이스팅이 일어난다.
// let은 재선언 X 재할당 O 이다.
// const는 재선언, 재할당 X 이다.

// 호이스팅
// 호이스팅은 코드를 실행전 변수선언과 함수선언이 스코프 최상단에 올라가져있는 현상을 뜻한다.
// 호이스팅은 var에서 생기며 일어나는 이유는 변수 선언은 선언 > 초기화 > 할당 순으로 이루어지는데
// var같은 경우는 선언과 동시에 초기화가 진행이 되기 때문에 호이스팅이 일어나게 된다.
// let과 const 같은 경우는 선언과 초기화가 따로 진행이 되고 사각지대를 통해 호이스팅이 이루어지지만 이루어지지 않는 것 처럼 보인다.

// 스코프
// 스코프는 함수가 유효 할 수 있는 범위를 뜻하며 지역변수와 전역변수로 나뉘어진다.
// 전역변수는 지역변수를 참조 할 수 있고 지역변수는 전역변수를 참조 할 수 없다.
// 지역변수는 함수와 블록스코프로 나뉘어 지는데
// 함수스코프는 var
// 블록스코프는 let, const가 있다

// 클로저
// 함수와 함수가 어휘적환경으로 조합된 것을 뜻하며 내부함수가 외부함수에 접근 할 수 있는 매커니즘이다.
// 외부함수 실행이 끝나도 어휘적환경에 접근 할 수 있다.

// this
// 자기가 속한 객체, 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.
// 호출 방식에 따라 바인딩할 객체가 동적으로 결정된다.

// Ajax
// XMLHttprequest를 사용하여 브라우저와 서버간 비동기 처리를 해주는 역할을한다.
// 현재는 XML말고 JSON을 사용함

// 구조분해할당
// 구조분해할당(비구조화할당)이라고 불리며 객체 배열의 값을 추출하여 변수에 바로 사용할 수 있게 도와주는 역할을 한다.

// spread, rest
// spread는 객체 배열의 값을 풀어놓는 역할을 하고
// rest는 spread와 다르게 전달받은 데이터 값을 객체 배열에 넣어주는 역할을 한다.

// 이벤트 루프
// 이벤트루프는 콜스택과 태스크큐를 주시하면서 콜스택이 비어있다면 태스크큐에 있는 작업을 콜스택에 넘겨주는 역할을 한다.
// 스택과 큐는 스택은 LIFO 후입선출이며 설거지한 접시, 컨트롤 + Z를 예시로 들수있고 큐는 FIFO 선입선출이며 키오스크 줄서기를 예시로 들 수 있다.

// 이벤트 위임
// 하위요소에서 이벤트를 할당하지 않고 상위요소에서 하위요소 이벤트를 제어해주는 역할을 한다.

// 이벤트 버블링
// 특정 화면 요소에서 이벤트 발생시 이벤트가 상위요소로 올라가지는 현상을 뜻함.

// 이벤트 캡처링
// 버블링과 다르게 상위요소에서 하위요소로 이벤트를 전달시켜줌

// 이벤트 전파
// DOM요소노드에서 이벤트 발생시 다른 DOM요소노드로 전파해주는것을 뜻함
// 3단계 1. 캡처링, 2. 타깃, 3. 버블링 순으로 전파가 된다.

// 깊은복사
// 새로운 메모리에 저장을하고 객체를 복사해오는 것이다.

// 얕은복사
// 기존에 있던 내용을 복사해오는 것 (참조값 복사)

// 함수 선언,표현 
// 함수 선언은 function 함수명 ()으로 선언이 되고 코드가 실행전에 로드가 되기 때문에 호이스팅이 발생 됨.
// 함수 표현식은 const 함수명 = function()으로 선언이 되고 코드를 실행을 하면 로드가 되기 때문에 호이스팅이 발생되지 않는다.

// 일반, 화살표 함수
// 일반 함수는 함수 호출방식에 따라 this가 바인딩할 객체를 동적으로 결정합니다.
// 화살표함수는 일반함수보다 간편하게 사용을 하려고 등장했으며 this는 상위 스코프를 가르키며 바인딩할 객체를 정적으로 결정합니다.

// map, forEach
// 둘의 공통점은 반복문으로 사용이되고 배열을 사용합니다.
// 차이점은 map은 새로운 배열을 생성하고 forEach는 기존 배열을 사용합니다.
// map은 반환값을 받지만 forEach는 undefined를 나타냅니다.

// Promise, Callback
// 콜백함수 - 다른함수에게 매개변수값을 넘겨주는 함수를 뜻하며
// 콜백함수를 사용하면 콜백 지옥에 빠지게 됩니다. 
// 콜백지옥은 콜백함수를 실행시에 익명함수로 사용이 되는데 함수가 반복이 되면서 익명함수의 들여쓰기가 감당이 안 될 정도가 되는 것을 콜백지옥이라고 합니다.

// 콜백지옥 해결방법은 promise사용, async/await 사용
// promise는 비동기 처리를 하면서 콜백지옥을 해결하기 위해 등장했습니다.
// promise 3가지 상태 (대기, 이행, 실패)가 있다.  성공시 resolve 실패시 reject
// promise를 사용하면 코드가 어려워지는데 좀 더 쉽게 사용하기 위해 
// async, await가 나타났습니다.

// async는 function 앞에 사용이되며 Promise를 반환합니다.
// await는 작업중 await를 만나면 작업을 중단하고 promise가 반환 될 때 까지 기다리고 반환이 완료 되면 원래 작업을 실행합니다.
